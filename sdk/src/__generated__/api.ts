/**
 * Generated by orval v6.30.2 üç∫
 * Do not edit manually.
 * Hypercerts API
 * API for uploading allow lists and hypercert metadata. Visit /graphql for the GraphQL API.
 * OpenAPI spec version: 1.0.0
 */
import axios from "axios";
import type { AxiosRequestConfig, AxiosResponse } from "axios";
export type ValidateAllowList200AnyOfTwo = {
  errors?: unknown;
  message: string;
  success?: unknown;
  valid: boolean;
};

export type ValidateAllowList200AnyOf = {
  errors: RecordStringStringOrStringArray;
  message: string;
  success: boolean;
  valid?: unknown;
};

export type ValidateAllowList200 = ValidateAllowList200AnyOf | ValidateAllowList200AnyOfTwo;

export type StoreAllowList201AnyOfTwoData = {
  cid: string;
};

export type StoreAllowList201AnyOfTwo = {
  data: StoreAllowList201AnyOfTwoData;
  errors?: unknown;
  message?: unknown;
  success: boolean;
};

export type StoreAllowList201AnyOf = {
  data?: unknown;
  errors: RecordStringStringOrStringArray;
  message: string;
  success: boolean;
};

export type StoreAllowList201 = StoreAllowList201AnyOf | StoreAllowList201AnyOfTwo;

export type UpdateOrderNonce200Data = {
  address: string;
  chain_id: number;
  created_at: string;
  nonce_counter: number;
};

export type UpdateOrderNonce200 = {
  data: UpdateOrderNonce200Data;
  message: string;
  success: boolean;
};

export type StoreOrder201AnyOfTwoData = {
  additionalParameters: string;
  amounts: number[];
  chainId: number;
  collection: string;
  collectionType: number;
  createdAt: string;
  currency: string;
  endTime: number;
  globalNonce: string;
  hash: string;
  id: string;
  itemIds: string[];
  orderNonce: string;
  price: string;
  quoteType: number;
  signature: string;
  signer: string;
  startTime: number;
  status: string;
  strategyId: number;
  subsetNonce: number;
};

export type StoreOrder201AnyOfTwo = {
  data: StoreOrder201AnyOfTwoData;
  error?: unknown;
  message: string;
  success: boolean;
};

export type StoreOrder201AnyOf = {
  data: unknown;
  error: unknown;
  message: string;
  success: boolean;
};

export type StoreOrder201 = StoreOrder201AnyOf | StoreOrder201AnyOfTwo;

export type ValidateMetadata200AnyOfSix = {
  errors?: unknown;
  message: string;
  valid: boolean;
};

export type ValidateMetadata200 = ValidateMetadata200AnyOf | ValidateMetadata200AnyOfSix;

export type ValidateMetadata200AnyOfErrorsAnyOfThree = {
  message: string;
  name?: unknown;
  receivedAllowlistCID: string;
};

export type ValidateMetadata200AnyOfErrorsAnyOfTwo = {
  message: string;
  name?: unknown;
  receivedAllowlistCID?: unknown;
};

export type ValidateMetadata200AnyOfErrorsAnyOf = {
  message: string;
  name: string;
  receivedAllowlistCID?: unknown;
};

export type ValidateMetadata200AnyOfErrors =
  | ValidateMetadata200AnyOfErrorsAnyOf
  | ValidateMetadata200AnyOfErrorsAnyOfTwo
  | ValidateMetadata200AnyOfErrorsAnyOfThree;

export type ValidateMetadata200AnyOf = {
  errors: ValidateMetadata200AnyOfErrors;
  message: string;
  valid: boolean;
};

export type StoreMetadata201 = StoreMetadata201AnyOf | StoreMetadata201AnyOfTwo;

export type StoreMetadata201AnyOfTwoErrorsAnyOfThree = {
  message: string;
  name?: unknown;
  receivedAllowlistCID: string;
};

export type StoreMetadata201AnyOfTwoErrorsAnyOfTwo = {
  message: string;
  name?: unknown;
  receivedAllowlistCID?: unknown;
};

export type StoreMetadata201AnyOfTwoErrorsAnyOf = {
  message: string;
  name: string;
  receivedAllowlistCID?: unknown;
};

export type StoreMetadata201AnyOfTwoErrors =
  | StoreMetadata201AnyOfTwoErrorsAnyOf
  | StoreMetadata201AnyOfTwoErrorsAnyOfTwo
  | StoreMetadata201AnyOfTwoErrorsAnyOfThree;

export type StoreMetadata201AnyOfTwo = {
  errors: StoreMetadata201AnyOfTwoErrors;
  message: string;
  valid: boolean;
};

export type StoreMetadata201AnyOf = {
  cid: string;
};

/**
 * Request body for creating a new allowlist.
 */
export interface CreateAllowListRequest {
  /** The dump of the OpenZeppelin MerkleTree containing [address, uint256] entries. See https://github.com/OpenZeppelin/merkle-tree for more information. */
  allowList: string;
  /** The total amount of units distributed via the allowlist. The total should amount to 1 eth in wei (1e18) units. */
  totalUnits: string;
}

export interface UpdateOrderNonceRequest {
  address: string;
  chainId: number;
}

export interface CreateOrderRequest {
  additionalParameters: string;
  amounts: number[];
  chainId: number;
  collection: string;
  collectionType: number;
  currency: string;
  endTime: number;
  globalNonce: string;
  itemIds: string[];
  orderNonce: string;
  price: string;
  quoteType: number;
  signature: string;
  signer: string;
  startTime: number;
  strategyId: number;
  subsetNonce: number;
}

export type ApiResponseErrors = RecordStringStringOrStringArray | Error[];

export interface ApiResponse {
  data?: unknown;
  errors?: ApiResponseErrors;
  message: string;
  success: boolean;
}

/**
 * Response object for a validation request.
 */
export interface ValidationResponse {
  errors?: RecordStringStringOrStringArray;
  message: string;
  valid: boolean;
}

export type HypercertMetadataPropertiesItem = {
  trait_type?: string;
  value?: string;
  [key: string]: unknown;
};

/**
 * Claim data for hypercert. ERC1155 Metadata compliant
 */
export interface HypercertMetadata {
  /** A CID pointer to the merke tree proof json on ipfs */
  allowList?: string;
  /** Describes the asset to which this token represents */
  description: string;
  /** An url pointing to the external website of the project */
  external_url?: string;
  hypercert?: HypercertClaimdata361;
  /** A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive. */
  image: string;
  /** Identifies the asset to which this token represents */
  name: string;
  properties?: HypercertMetadataPropertiesItem[];
  /** Describes the asset to which this token represents */
  ref?: string;
  /** The version of Hypercert schema used to describe this hypercert */
  version?: string;
}

/**
 * Work time period. The value is UNIX time in seconds from epoch.
 */
export type HypercertClaimdata361WorkTimeframe = {
  display_value?: string;
  name?: string;
  value?: number[];
  [key: string]: unknown;
};

/**
 * Scopes of work
 */
export type HypercertClaimdata361WorkScope = {
  display_value?: string;
  excludes?: string[];
  name?: string;
  value?: string[];
  [key: string]: unknown;
};

/**
 * Rights
 */
export type HypercertClaimdata361Rights = {
  display_value?: string;
  excludes?: string[];
  name?: string;
  value?: string[];
  [key: string]: unknown;
};

/**
 * Impact time period. The value is UNIX time in seconds from epoch.
 */
export type HypercertClaimdata361ImpactTimeframe = {
  display_value?: string;
  name?: string;
  value?: number[];
  [key: string]: unknown;
};

/**
 * Scopes of impact
 */
export type HypercertClaimdata361ImpactScope = {
  display_value?: string;
  excludes?: string[];
  name?: string;
  value?: string[];
  [key: string]: unknown;
};

/**
 * Contributors
 */
export type HypercertClaimdata361Contributors = {
  display_value?: string;
  name?: string;
  value?: string[];
  [key: string]: unknown;
};

/**
 * Properties of an impact claim
 */
export interface HypercertClaimdata361 {
  /** Contributors */
  contributors: HypercertClaimdata361Contributors;
  /** Scopes of impact */
  impact_scope: HypercertClaimdata361ImpactScope;
  /** Impact time period. The value is UNIX time in seconds from epoch. */
  impact_timeframe: HypercertClaimdata361ImpactTimeframe;
  /** Rights */
  rights?: HypercertClaimdata361Rights;
  /** Scopes of work */
  work_scope: HypercertClaimdata361WorkScope;
  /** Work time period. The value is UNIX time in seconds from epoch. */
  work_timeframe: HypercertClaimdata361WorkTimeframe;
  [key: string]: unknown;
}

/**
 * Response object for a store request.
 */
export interface StoreResponse {
  data?: unknown;
  errors?: StoreResponseErrors;
  message: string;
  success: boolean;
}

export interface Error {
  message: string;
  name: string;
  stack?: string;
}

/**
 * Construct a type with a set of properties K of type T
 */
export interface RecordStringStringOrStringArray {
  [key: string]: string | string[];
}

export type StoreResponseErrors = RecordStringStringOrStringArray | Error[];

/**
 * Submits a new hypercert metadata object for validation and storage on IPFS. While we maintain a database of allowlists, the allowlist itself is stored on IPFS.
 */
export const storeMetadata = <TData = AxiosResponse<StoreMetadata201>>(
  hypercertMetadata: HypercertMetadata,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`/v1/metadata`, hypercertMetadata, options);
};

/**
 * Submits a new hypercert metadata object for validation.
 */
export const validateMetadata = <TData = AxiosResponse<ValidateMetadata200>>(
  hypercertMetadata: HypercertMetadata,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`/v1/metadata/validate`, hypercertMetadata, options);
};

/**
 * Submits a new order for validation and storage on the database.
 */
export const storeOrder = <TData = AxiosResponse<StoreOrder201>>(
  createOrderRequest: CreateOrderRequest,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`/v1/marketplace/orders`, createOrderRequest, options);
};

/**
 * Updates and returns the order nonce for a user on a specific chain.
 */
export const updateOrderNonce = <TData = AxiosResponse<UpdateOrderNonce200>>(
  updateOrderNonceRequest: UpdateOrderNonceRequest,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`/v1/marketplace/order-nonce`, updateOrderNonceRequest, options);
};

/**
 * Submits a new allowlist for validation and storage on IPFS. While we maintain a database of allowlists, the allowlist itself is stored on IPFS.
Try to keep a backup of the allowlist for recovery purposes.

Provide the dump of the OpenZeppelin MerkleTree and the total units.
 */
export const storeAllowList = <TData = AxiosResponse<StoreAllowList201>>(
  createAllowListRequest: CreateAllowListRequest,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`/v1/allowlists`, createAllowListRequest, options);
};

/**
 * Submits a new allowlist for validation.

Provide the dump of the OpenZeppelin MerkleTree and the total units.
 */
export const validateAllowList = <TData = AxiosResponse<ValidateAllowList200>>(
  createAllowListRequest: CreateAllowListRequest,
  options?: AxiosRequestConfig,
): Promise<TData> => {
  return axios.post(`/v1/allowlists/validate`, createAllowListRequest, options);
};

export type StoreMetadataResult = AxiosResponse<StoreMetadata201>;
export type ValidateMetadataResult = AxiosResponse<ValidateMetadata200>;
export type StoreOrderResult = AxiosResponse<StoreOrder201>;
export type UpdateOrderNonceResult = AxiosResponse<UpdateOrderNonce200>;
export type StoreAllowListResult = AxiosResponse<StoreAllowList201>;
export type ValidateAllowListResult = AxiosResponse<ValidateAllowList200>;
