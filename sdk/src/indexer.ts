import { logger } from "./utils";
import { defaultQueryParams } from "./indexer/utils";
import {
  HypercertClientConfig,
  HypercertIndexerInterface,
  IndexerEnvironment,
  QueryParams,
  QueryParamsWithChainId,
} from "./types";

import { AnyVariables, cacheExchange, Client, fetchExchange } from "@urql/core";
import {
  ClaimByIdDocument,
  ClaimByIdQueryVariables,
  ClaimsByOwnerDocument,
  ClaimsByOwnerQueryVariables,
  ClaimTokenByIdDocument,
  ClaimTokenByIdQueryVariables,
  ClaimTokensByClaimDocument,
  ClaimTokensByClaimQueryVariables,
  ClaimTokensByOwnerDocument,
  ClaimTokensByOwnerQueryVariables,
  RecentClaimsDocument,
  RecentClaimsQueryVariables,
} from "./indexer/gql/graphql";
import { DEPLOYMENTS } from "./constants";
import { TypedDocumentNode } from "@graphql-typed-document-node/core";
import { parseClaimOrFractionId } from "./utils/parsing";

/**
 * A class that provides indexing functionality for Hypercerts.
 *
 * This class implements the `HypercertIndexerInterface` and provides methods for retrieving claims by owner and by ID. It uses the Graph client for indexing.
 * Because of the autogenerated Graph client packed with the SDK, this class is not recommended for custom Graph deployments.
 *
 * @example
 * const indexer = new HypercertIndexer({ graphUrl: 'your-graph-url', graphName: 'your-graph-name' });
 * const claims = await indexer.claimsByOwner('your-address');
 */
export class HypercertIndexer implements HypercertIndexerInterface {
  /** The Graph client used by the indexer. */
  private environment: IndexerEnvironment;

  private graphClients: Map<number, Client>;

  /**
   * Creates a new instance of the `HypercertIndexer` class.
   * @param options The configuration options for the indexer.
   */
  constructor(options: Partial<HypercertClientConfig>) {
    logger.info("Creating HypercertIndexer", "constructor", { name: options.graphName, url: options.graphUrl });
    if (!options.graphUrl) throw new Error("Missing graphUrl");
    this.environment = options.indexerEnvironment || "test";

    const environments = HypercertIndexer.getDeploymentsForEnvironment(this.environment);

    this.graphClients = new Map<number, Client>();
    for (const [chainId, deployment] of environments) {
      if (!deployment.graphUrl) {
        console.log(`Missing graphUrl for chain ${chainId}`);
        continue;
      }
      this.graphClients.set(
        parseInt(chainId),
        new Client({
          url: deployment.graphUrl,
          exchanges: [cacheExchange, fetchExchange],
        }),
      );
    }
  }

  static getDeploymentsForEnvironment(environment: IndexerEnvironment) {
    return Object.entries(DEPLOYMENTS).filter(([_, deployment]) => {
      if (environment === "test") {
        return deployment.isTestnet;
      }

      if (environment === "production") {
        return !deployment.isTestnet;
      }

      return true;
    });
  }

  performQuery = async <Data = any, Variables extends AnyVariables = any>(
    query: TypedDocumentNode<Data, Variables>,
    variables: Variables,
    chainId?: number,
  ) => {
    const chains = chainId ? [chainId] : Array.from(this.graphClients.keys());
    return await Promise.all(
      chains.map(async (c) => {
        const client = this.graphClients.get(c);
        if (!client) {
          throw new Error(`No client found for chain ${chainId}`);
        }

        return client
          .query<Data, Variables>(query, variables)
          .toPromise()
          .then((res) => {
            if (res.error) {
              throw res.error;
            }

            return res.data;
          });
      }),
    );
  };

  /**
   * Gets the Graph client used by the indexer.
   * @returns The Graph client.
   */
  getGraphClient(chainId: number): Client {
    const client = this.graphClients.get(chainId);
    if (!client) {
      throw new Error(`No client found for chain ${chainId}`);
    }
    return client;
  }

  /**
   * Gets the claims owned by a given address.
   * @param owner The address of the owner.
   * @param params The query parameters.
   * @returns A Promise that resolves to the claims.
   */
  claimsByOwner = async (owner: string, { chainId, ...params }: QueryParamsWithChainId = defaultQueryParams) => {
    const query = ClaimsByOwnerDocument;
    const variables: ClaimsByOwnerQueryVariables = {
      owner,
      ...params,
    };

    const results = await this.performQuery(query, variables, chainId);
    const claims = results.flatMap((result) => result?.claims || []);
    return {
      claims,
    };
  };

  /**
   * Gets a claim by its ID.
   * @param claimId The ID of the claim.
   * @returns A Promise that resolves to the claim.
   */
  claimById = async (claimId: string) => {
    const query = ClaimByIdDocument;
    const { chainId } = parseClaimOrFractionId(claimId);
    const variables: ClaimByIdQueryVariables = {
      id: claimId,
    };
    const results = await this.performQuery(query, variables, chainId);

    return results[0];
  };
  /**
   * Gets the most recent claims.
   * @param params The query parameters.
   * @returns A Promise that resolves to the claims.
   */
  firstClaims = async ({ chainId, ...params }: QueryParamsWithChainId = defaultQueryParams) => {
    const query = RecentClaimsDocument;
    const variables: RecentClaimsQueryVariables = {
      ...params,
    };

    const results = await this.performQuery(query, variables, chainId);
    const claims = results.flatMap((result) => result?.claims || []);
    return {
      claims,
    };
  };

  /**
   * Gets the claim tokens owned by a given address.
   * @param owner The address of the owner.
   * @param params The query parameters.
   * @returns A Promise that resolves to the claim tokens.
   */
  fractionsByOwner = async (owner: string, { chainId, ...params }: QueryParamsWithChainId = defaultQueryParams) => {
    const query = ClaimTokensByOwnerDocument;
    const variables: ClaimTokensByOwnerQueryVariables = {
      owner,
      ...params,
    };

    const results = await this.performQuery(query, variables, chainId);
    const claimTokens = results.flatMap((result) => result?.claimTokens || []);
    return {
      claimTokens,
    };
  };

  /**
   * Gets the claim tokens for a given claim.
   * @param claimId The ID of the claim.
   * @param params The query parameters.
   * @returns A Promise that resolves to the claim tokens.
   */
  fractionsByClaim = async (claimId: string, params: QueryParams = defaultQueryParams) => {
    const query = ClaimTokensByClaimDocument;
    const { chainId } = parseClaimOrFractionId(claimId);
    const variables: ClaimTokensByClaimQueryVariables = {
      claimId,
      ...params,
    };

    const results = await this.performQuery(query, variables, chainId);
    return results[0];
  };

  /**
   * Gets a claim token by its ID.
   * @param fractionId The ID of the claim token.
   * @returns A Promise that resolves to the claim token.
   */
  fractionById = async (fractionId: string) => {
    const query = ClaimTokenByIdDocument;
    const { chainId } = parseClaimOrFractionId(fractionId);

    const variables: ClaimTokenByIdQueryVariables = {
      claimTokenId: fractionId,
    };

    const results = await this.performQuery(query, variables, chainId);
    return results[0];
  };
}
